안녕하세요\! 다른 사람과 최고 점수를 연동해서 공유하고 싶으시군요. 그렇게 하려면 모든 사람이 접속할 수 있는 **온라인 서버**를 이용해야 합니다. `jsonbin.io`가 바로 그 서버 역할을 해주는 서비스입니다.

현재 코드의 가장 큰 문제는 개인 컴퓨터(브라우저)에만 점수를 저장하는 로직(`localStorage`)과 서버에 저장하는 로직(`jsonbin.io`)이 **섞여 있고, 일부 코드가 잘못 작성되어 있어** 제대로 작동하지 않는 것입니다.

다른 사람과 점수를 연동하려면 **서버 방식(`jsonbin.io`)으로 통일**해야 합니다.

-----

## 해결 방법: 단계별 안내

아래 안내에 따라 진행하시면 다른 사람들과 함께 쓰는 온라인 최고 점수판을 만들 수 있습니다.

### 1단계: `jsonbin.io`에서 새로운 최고 점수 데이터 만들기

먼저, `jsonbin.io`에 접속해서 새로운 점수 데이터를 저장할 "저장소(Bin)"를 만들어야 합니다.

1.  [jsonbin.io](https://jsonbin.io/)에 로그인합니다.

2.  **Create your first bin** 또는 **New Collection** 버튼을 눌러 새 Bin을 만듭니다.

3.  아래의 JSON 코드를 복사하여 에디터에 붙여넣습니다. 이 코드가 새로운 초기 점수판이 됩니다. 원하는 이름과 점수로 자유롭게 수정하세요.

    ```json
    [
      {
        "name": "TETRIS_GOD",
        "score": 15000
      },
      {
        "name": "BLOCK_MASTER",
        "score": 11200
      },
      {
        "name": "Pro_Gamer",
        "score": 9800
      },
      {
        "name": "CHALLENGER",
        "score": 7500
      },
      {
        "name": "NEWBIE",
        "score": 3100
      }
    ]
    ```

4.  Bin을 저장합니다.

### 2단계: `BIN_ID`와 `API_KEY` 확인하기

`jsonbin.io`에서 방금 만든 저장소의 \*\*주소(`BIN_ID`)\*\*와 \*\*비밀 키(`API_KEY`)\*\*를 복사해야 합니다.

  * **`BIN_ID`**: Bin을 저장하면 보이는 URL의 마지막 부분입니다. (예: `https://api.jsonbin.io/v3/b/`**`여기가_BIN_ID`**)
  * **`API_KEY`**: `jsonbin.io` 왼쪽 메뉴의 **API Keys**에서 확인할 수 있는 `X-Master-Key` 값입니다.

### 3단계: 전체 코드 수정하기

⚠️ **중요:** 아래는 기존 코드의 문제점을 모두 수정한 **전체 코드**입니다. 이 코드를 통째로 복사해서 사용하세요. `localStorage` 관련 코드를 모두 제거하고, `jsonbin.io` 연동 로직을 완벽하게 수정했습니다.

**수정된 전체 코드:**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테트리스 게임 (온라인 랭킹)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column; /* 세로 정렬 */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* 상하 여백 추가 */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-sizing: border-box;
        }
        .game-container {
            display: flex;
            gap: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .game-board { position: relative; }
        canvas {
            border: 2px solid #fff;
            background: #000;
            border-radius: 5px;
        }
        .info-panel { color: white; min-width: 200px; }
        .score-board {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; /* 글자색 추가 */
        }
        .score-item { display: flex; justify-content: space-between; margin: 8px 0; font-size: 16px; }
        .next-piece { background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; }
        .next-canvas { border: 1px solid #fff; background: #000; border-radius: 3px; margin-top: 10px; }
        .controls { background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.2); margin-top: 20px; }
        .controls h3 { margin-top: 0; color: #fff; }
        .controls p { margin: 5px 0; color: #ccc; font-size: 14px; }
        .game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.8); color: white; padding: 30px; border-radius: 15px; text-align: center; display: none; width: 80%; }
        .restart-btn { background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-top: 15px; }
        .restart-btn:hover { background: #45a049; }
        .high-score-container { /* 최고 점수판 스타일 */
            width: 90%;
            max-width: 580px; /* 게임 컨테이너 너비와 비슷하게 맞춤 */
            margin-top: 20px;
        }
        #highScoreList {
             padding-left: 20px;
             color: #ffd700;
             font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-board">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
            <div class="game-over" id="gameOver">
                <h2>게임 오버!</h2>
                <p>점수: <span id="finalScore">0</span></p>
                <div id="nameInputBox" style="margin:15px 0; display:none;">
                    <input type="text" id="playerName" maxlength="10" placeholder="이름 입력 (10자 이내)" style="padding:8px; border-radius:4px; border:1px solid #ccc; width: 70%;">
                    <button class="restart-btn" id="saveScoreBtn" style="padding: 8px 12px; margin-top: 0;">저장</button>
                </div>
                <button class="restart-btn" onclick="restartGame()">다시 시작</button>
            </div>
        </div>
        <div class="info-panel">
            <div class="score-board">
                <div class="score-item"><span>점수:</span><span id="score">0</span></div>
                <div class="score-item"><span>레벨:</span><span id="level">1</span></div>
                <div class="score-item"><span>라인:</span><span id="lines">0</span></div>
            </div>
            <div class="next-piece">
                <h3>다음 블록</h3>
                <canvas id="nextCanvas" width="120" height="120"></canvas>
            </div>
            <div class="controls">
                <h3>조작법</h3>
                <p>←/→ : 이동</p>
                <p>↓ : 빠른 낙하</p>
                <p>↑ : 회전</p>
                <p>스페이스 : 즉시 낙하</p>
                <p>P, ESC : 일시정지/재개</p>
                <p>R : 즉시 리셋</p>
            </div>
        </div>
    </div>

    <div class="score-board high-score-container">
        <div style="font-weight:bold; margin-bottom:10px; font-size:20px;">🏆 최고 점수 TOP 5 🏆</div>
        <ol id="highScoreList"></ol>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 30;
        
        const TETROMINOS = {
            I: { shape: [[1, 1, 1, 1]], color: '#00f0f0' },
            O: { shape: [[1, 1], [1, 1]], color: '#f0f000' },
            T: { shape: [[0, 1, 0], [1, 1, 1]], color: '#a000f0' },
            S: { shape: [[0, 1, 1], [1, 1, 0]], color: '#00f000' },
            Z: { shape: [[1, 1, 0], [0, 1, 1]], color: '#f00000' },
            J: { shape: [[1, 0, 0], [1, 1, 1]], color: '#0000f0' },
            L: { shape: [[0, 0, 1], [1, 1, 1]], color: '#f0a000' }
        };
        
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let gameRunning = false;
        let score = 0;
        let level = 1;
        let lines = 0;
        let dropTime = 0;
        let dropInterval = 1000;
        let paused = false;
        let animationFrameId;

        // --- ⚙️ jsonbin.io 설정 (매우 중요) ---
        // 2단계에서 복사한 본인의 BIN_ID와 API_KEY로 교체해주세요.
        const BIN_ID = 'YOUR_BIN_ID'; // 👈 본인의 BIN ID로 교체
        const API_KEY = 'YOUR_API_KEY'; // 👈 본인의 Master Key로 교체
        const HIGH_SCORE_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
        const MAX_HIGH_SCORES = 5;
        
        function initBoard() {
            board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
        }
        
        function createPiece() {
            const pieces = Object.keys(TETROMINOS);
            const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
            const tetromino = TETROMINOS[randomPiece];
            return {
                shape: tetromino.shape,
                color: tetromino.color,
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(tetromino.shape[0].length / 2),
                y: 0
            };
        }
        
        function drawBlock(ctx, x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#333';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
        
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            board.forEach((row, y) => {
                row.forEach((color, x) => {
                    if (color) drawBlock(ctx, x, y, color);
                });
            });
            if (currentPiece) drawPiece(ctx, currentPiece);
        }
        
        function drawPiece(ctx, piece) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) drawBlock(ctx, piece.x + x, piece.y + y, piece.color);
                });
            });
        }
        
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                const pieceSize = 20;
                const offsetX = (nextCanvas.width - nextPiece.shape[0].length * pieceSize) / 2;
                const offsetY = (nextCanvas.height - nextPiece.shape.length * pieceSize) / 2;
                
                nextPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            nextCtx.fillStyle = nextPiece.color;
                            nextCtx.fillRect(offsetX + x * pieceSize, offsetY + y * pieceSize, pieceSize, pieceSize);
                            nextCtx.strokeStyle = '#333';
                            nextCtx.strokeRect(offsetX + x * pieceSize, offsetY + y * pieceSize, pieceSize, pieceSize);
                        }
                    });
                });
            }
        }
        
        function isValidMove(piece, dx, dy, rotation = null) {
            const shape = rotation || piece.shape;
            const newX = piece.x + dx;
            const newY = piece.y + dy;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const newPosX = newX + x;
                        const newPosY = newY + y;
                        if (newPosX < 0 || newPosX >= BOARD_WIDTH || newPosY >= BOARD_HEIGHT || (newPosY >= 0 && board[newPosY][newPosX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        function rotatePiece(piece) {
            const shape = piece.shape;
            return shape[0].map((_, colIndex) => shape.map(row => row[colIndex]).reverse());
        }
        
        function placePiece() {
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
                });
            });
            clearLines();
            currentPiece = nextPiece;
            nextPiece = createPiece();
            
            if (!isValidMove(currentPiece, 0, 0)) gameOver();
        }
        
        function clearLines() {
            let linesCleared = 0;
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    board.splice(y, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(0));
                    linesCleared++;
                    y++; 
                }
            }
            if (linesCleared > 0) {
                lines += linesCleared;
                const scoreMultipliers = [0, 100, 300, 500, 800];
                score += (scoreMultipliers[linesCleared] || scoreMultipliers[4]) * level;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level - 1) * 75);
                updateScore();
            }
        }
        
        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;
        }
        
        async function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';

            const scores = await fetchHighScores();
            const isHighScore = score > 0 && (scores.length < MAX_HIGH_SCORES || score > scores[scores.length-1].score);
            
            const nameBox = document.getElementById('nameInputBox');
            if (isHighScore) {
                nameBox.style.display = 'block';
                document.getElementById('playerName').value = '';
                setTimeout(() => document.getElementById('playerName').focus(), 100);
            } else {
                nameBox.style.display = 'none';
            }
        }
        
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            score = 0;
            level = 1;
            lines = 0;
            dropInterval = 1000;
            updateScore();
            startGame();
        }
        
        function startGame() {
            initBoard();
            currentPiece = createPiece();
            nextPiece = createPiece();
            gameRunning = true;
            paused = false;
            dropTime = Date.now();
            updateHighScoreList();
            gameLoop();
        }
        
        function gameLoop() {
            if (!gameRunning) return;
            if (!paused) {
                update();
                draw();
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function update() {
            const now = Date.now();
            if (now - dropTime > dropInterval) {
                if (isValidMove(currentPiece, 0, 1)) {
                    currentPiece.y++;
                } else {
                    placePiece();
                }
                dropTime = now;
            }
        }
        
        function draw() {
            drawBoard();
            drawNextPiece();
        }

        function togglePause() {
             if (!gameRunning) return;
             paused = !paused;
             if (!paused) {
                 dropTime = Date.now();
             } else {
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                 ctx.fillStyle = 'white';
                 ctx.font = '30px Arial';
                 ctx.textAlign = 'center';
                 ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
             }
        }
        
        document.addEventListener('keydown', (e) => {
            if (paused) {
                 if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') togglePause();
                 return;
            }
            if (!gameRunning) return;
            
            switch (e.key) {
                case 'ArrowLeft': if (isValidMove(currentPiece, -1, 0)) currentPiece.x--; break;
                case 'ArrowRight': if (isValidMove(currentPiece, 1, 0)) currentPiece.x++; break;
                case 'ArrowDown':
                    if (isValidMove(currentPiece, 0, 1)) {
                        currentPiece.y++;
                        score += 1;
                        updateScore();
                    }
                    break;
                case 'ArrowUp':
                    const rotated = rotatePiece(currentPiece);
                    if (isValidMove(currentPiece, 0, 0, rotated)) currentPiece.shape = rotated;
                    break;
                case ' ':
                    e.preventDefault();
                    while (isValidMove(currentPiece, 0, 1)) {
                        currentPiece.y++;
                        score += 2;
                    }
                    updateScore();
                    placePiece();
                    break;
                case 'p': case 'P': case 'Escape': togglePause(); break;
                case 'r': case 'R': restartGame(); break;
            }
        });
        
        // --- 최고 점수 관련 함수 (jsonbin.io 서버 연동) ---

        async function fetchHighScores() {
            if (!API_KEY || !BIN_ID || API_KEY === 'YOUR_API_KEY' || BIN_ID === 'YOUR_BIN_ID') {
                 console.warn("jsonbin.io API Key 또는 BIN ID가 설정되지 않았습니다.");
                 return [];
            }
            try {
                const res = await fetch(`${HIGH_SCORE_URL}/latest`, {
                    headers: { 'X-Master-Key': API_KEY }
                });
                if (!res.ok) return []; // 오류가 있어도 빈 배열 반환
                const data = await res.json();
                return Array.isArray(data.record) ? data.record : [];
            } catch (e) {
                console.error("최고 점수를 불러오는 데 실패했습니다:", e);
                return [];
            }
        }

        async function saveHighScoresToServer(scores) {
             if (!API_KEY || !BIN_ID || API_KEY === 'YOUR_API_KEY' || BIN_ID === 'YOUR_BIN_ID') return;
            try {
                await fetch(HIGH_SCORE_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': API_KEY
                    },
                    body: JSON.stringify(scores)
                });
            } catch (e) {
                console.error("최고 점수를 저장하는 데 실패했습니다:", e);
            }
        }

        async function updateHighScoreList() {
            const list = document.getElementById('highScoreList');
            if (!list) return;
            list.innerHTML = '<li>점수판을 불러오는 중...</li>';
            
            const scores = await fetchHighScores();
            scores.sort((a, b) => b.score - a.score);

            list.innerHTML = '';
            if (scores.length === 0) {
                 list.innerHTML = '<li>아직 등록된 점수가 없습니다.</li>';
                 return;
            }

            scores.slice(0, MAX_HIGH_SCORES).forEach((entry) => {
                const li = document.createElement('li');
                li.textContent = `${entry.name} - ${entry.score.toLocaleString()}`;
                list.appendChild(li);
            });
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const saveBtn = document.getElementById('saveScoreBtn');
            if (saveBtn) {
                saveBtn.onclick = async function() {
                    this.disabled = true; // 중복 저장 방지
                    const name = document.getElementById('playerName').value.trim() || '익명';
                    
                    let scores = await fetchHighScores();
                    scores.push({ name, score });
                    scores.sort((a, b) => b.score - a.score);
                    scores = scores.slice(0, MAX_HIGH_SCORES);
                    
                    await saveHighScoresToServer(scores);
                    await updateHighScoreList();
                    
                    document.getElementById('nameInputBox').style.display = 'none';
                    this.disabled = false;
                };
            }
            startGame();
        });
    </script>
</body>
</html>
```