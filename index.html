ì•ˆë…•í•˜ì„¸ìš”\! ë‹¤ë¥¸ ì‚¬ëŒê³¼ ìµœê³  ì ìˆ˜ë¥¼ ì—°ë™í•´ì„œ ê³µìœ í•˜ê³  ì‹¶ìœ¼ì‹œêµ°ìš”. ê·¸ë ‡ê²Œ í•˜ë ¤ë©´ ëª¨ë“  ì‚¬ëŒì´ ì ‘ì†í•  ìˆ˜ ìˆëŠ” **ì˜¨ë¼ì¸ ì„œë²„**ë¥¼ ì´ìš©í•´ì•¼ í•©ë‹ˆë‹¤. `jsonbin.io`ê°€ ë°”ë¡œ ê·¸ ì„œë²„ ì—­í• ì„ í•´ì£¼ëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.

í˜„ì¬ ì½”ë“œì˜ ê°€ì¥ í° ë¬¸ì œëŠ” ê°œì¸ ì»´í“¨í„°(ë¸Œë¼ìš°ì €)ì—ë§Œ ì ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ë¡œì§(`localStorage`)ê³¼ ì„œë²„ì— ì €ì¥í•˜ëŠ” ë¡œì§(`jsonbin.io`)ì´ **ì„ì—¬ ìˆê³ , ì¼ë¶€ ì½”ë“œê°€ ì˜ëª» ì‘ì„±ë˜ì–´ ìˆì–´** ì œëŒ€ë¡œ ì‘ë™í•˜ì§€ ì•ŠëŠ” ê²ƒì…ë‹ˆë‹¤.

ë‹¤ë¥¸ ì‚¬ëŒê³¼ ì ìˆ˜ë¥¼ ì—°ë™í•˜ë ¤ë©´ **ì„œë²„ ë°©ì‹(`jsonbin.io`)ìœ¼ë¡œ í†µì¼**í•´ì•¼ í•©ë‹ˆë‹¤.

-----

## í•´ê²° ë°©ë²•: ë‹¨ê³„ë³„ ì•ˆë‚´

ì•„ë˜ ì•ˆë‚´ì— ë”°ë¼ ì§„í–‰í•˜ì‹œë©´ ë‹¤ë¥¸ ì‚¬ëŒë“¤ê³¼ í•¨ê»˜ ì“°ëŠ” ì˜¨ë¼ì¸ ìµœê³  ì ìˆ˜íŒì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 1ë‹¨ê³„: `jsonbin.io`ì—ì„œ ìƒˆë¡œìš´ ìµœê³  ì ìˆ˜ ë°ì´í„° ë§Œë“¤ê¸°

ë¨¼ì €, `jsonbin.io`ì— ì ‘ì†í•´ì„œ ìƒˆë¡œìš´ ì ìˆ˜ ë°ì´í„°ë¥¼ ì €ì¥í•  "ì €ì¥ì†Œ(Bin)"ë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤.

1.  [jsonbin.io](https://jsonbin.io/)ì— ë¡œê·¸ì¸í•©ë‹ˆë‹¤.

2.  **Create your first bin** ë˜ëŠ” **New Collection** ë²„íŠ¼ì„ ëˆŒëŸ¬ ìƒˆ Binì„ ë§Œë“­ë‹ˆë‹¤.

3.  ì•„ë˜ì˜ JSON ì½”ë“œë¥¼ ë³µì‚¬í•˜ì—¬ ì—ë””í„°ì— ë¶™ì—¬ë„£ìŠµë‹ˆë‹¤. ì´ ì½”ë“œê°€ ìƒˆë¡œìš´ ì´ˆê¸° ì ìˆ˜íŒì´ ë©ë‹ˆë‹¤. ì›í•˜ëŠ” ì´ë¦„ê³¼ ì ìˆ˜ë¡œ ììœ ë¡­ê²Œ ìˆ˜ì •í•˜ì„¸ìš”.

    ```json
    [
      {
        "name": "TETRIS_GOD",
        "score": 15000
      },
      {
        "name": "BLOCK_MASTER",
        "score": 11200
      },
      {
        "name": "Pro_Gamer",
        "score": 9800
      },
      {
        "name": "CHALLENGER",
        "score": 7500
      },
      {
        "name": "NEWBIE",
        "score": 3100
      }
    ]
    ```

4.  Binì„ ì €ì¥í•©ë‹ˆë‹¤.

### 2ë‹¨ê³„: `BIN_ID`ì™€ `API_KEY` í™•ì¸í•˜ê¸°

`jsonbin.io`ì—ì„œ ë°©ê¸ˆ ë§Œë“  ì €ì¥ì†Œì˜ \*\*ì£¼ì†Œ(`BIN_ID`)\*\*ì™€ \*\*ë¹„ë°€ í‚¤(`API_KEY`)\*\*ë¥¼ ë³µì‚¬í•´ì•¼ í•©ë‹ˆë‹¤.

  * **`BIN_ID`**: Binì„ ì €ì¥í•˜ë©´ ë³´ì´ëŠ” URLì˜ ë§ˆì§€ë§‰ ë¶€ë¶„ì…ë‹ˆë‹¤. (ì˜ˆ: `https://api.jsonbin.io/v3/b/`**`ì—¬ê¸°ê°€_BIN_ID`**)
  * **`API_KEY`**: `jsonbin.io` ì™¼ìª½ ë©”ë‰´ì˜ **API Keys**ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆëŠ” `X-Master-Key` ê°’ì…ë‹ˆë‹¤.

### 3ë‹¨ê³„: ì „ì²´ ì½”ë“œ ìˆ˜ì •í•˜ê¸°

âš ï¸ **ì¤‘ìš”:** ì•„ë˜ëŠ” ê¸°ì¡´ ì½”ë“œì˜ ë¬¸ì œì ì„ ëª¨ë‘ ìˆ˜ì •í•œ **ì „ì²´ ì½”ë“œ**ì…ë‹ˆë‹¤. ì´ ì½”ë“œë¥¼ í†µì§¸ë¡œ ë³µì‚¬í•´ì„œ ì‚¬ìš©í•˜ì„¸ìš”. `localStorage` ê´€ë ¨ ì½”ë“œë¥¼ ëª¨ë‘ ì œê±°í•˜ê³ , `jsonbin.io` ì—°ë™ ë¡œì§ì„ ì™„ë²½í•˜ê²Œ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.

**ìˆ˜ì •ëœ ì „ì²´ ì½”ë“œ:**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„ (ì˜¨ë¼ì¸ ë­í‚¹)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column; /* ì„¸ë¡œ ì •ë ¬ */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* ìƒí•˜ ì—¬ë°± ì¶”ê°€ */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-sizing: border-box;
        }
        .game-container {
            display: flex;
            gap: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .game-board { position: relative; }
        canvas {
            border: 2px solid #fff;
            background: #000;
            border-radius: 5px;
        }
        .info-panel { color: white; min-width: 200px; }
        .score-board {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; /* ê¸€ììƒ‰ ì¶”ê°€ */
        }
        .score-item { display: flex; justify-content: space-between; margin: 8px 0; font-size: 16px; }
        .next-piece { background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; }
        .next-canvas { border: 1px solid #fff; background: #000; border-radius: 3px; margin-top: 10px; }
        .controls { background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.2); margin-top: 20px; }
        .controls h3 { margin-top: 0; color: #fff; }
        .controls p { margin: 5px 0; color: #ccc; font-size: 14px; }
        .game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.8); color: white; padding: 30px; border-radius: 15px; text-align: center; display: none; width: 80%; }
        .restart-btn { background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-top: 15px; }
        .restart-btn:hover { background: #45a049; }
        .high-score-container { /* ìµœê³  ì ìˆ˜íŒ ìŠ¤íƒ€ì¼ */
            width: 90%;
            max-width: 580px; /* ê²Œì„ ì»¨í…Œì´ë„ˆ ë„ˆë¹„ì™€ ë¹„ìŠ·í•˜ê²Œ ë§ì¶¤ */
            margin-top: 20px;
        }
        #highScoreList {
             padding-left: 20px;
             color: #ffd700;
             font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-board">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
            <div class="game-over" id="gameOver">
                <h2>ê²Œì„ ì˜¤ë²„!</h2>
                <p>ì ìˆ˜: <span id="finalScore">0</span></p>
                <div id="nameInputBox" style="margin:15px 0; display:none;">
                    <input type="text" id="playerName" maxlength="10" placeholder="ì´ë¦„ ì…ë ¥ (10ì ì´ë‚´)" style="padding:8px; border-radius:4px; border:1px solid #ccc; width: 70%;">
                    <button class="restart-btn" id="saveScoreBtn" style="padding: 8px 12px; margin-top: 0;">ì €ì¥</button>
                </div>
                <button class="restart-btn" onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
            </div>
        </div>
        <div class="info-panel">
            <div class="score-board">
                <div class="score-item"><span>ì ìˆ˜:</span><span id="score">0</span></div>
                <div class="score-item"><span>ë ˆë²¨:</span><span id="level">1</span></div>
                <div class="score-item"><span>ë¼ì¸:</span><span id="lines">0</span></div>
            </div>
            <div class="next-piece">
                <h3>ë‹¤ìŒ ë¸”ë¡</h3>
                <canvas id="nextCanvas" width="120" height="120"></canvas>
            </div>
            <div class="controls">
                <h3>ì¡°ì‘ë²•</h3>
                <p>â†/â†’ : ì´ë™</p>
                <p>â†“ : ë¹ ë¥¸ ë‚™í•˜</p>
                <p>â†‘ : íšŒì „</p>
                <p>ìŠ¤í˜ì´ìŠ¤ : ì¦‰ì‹œ ë‚™í•˜</p>
                <p>P, ESC : ì¼ì‹œì •ì§€/ì¬ê°œ</p>
                <p>R : ì¦‰ì‹œ ë¦¬ì…‹</p>
            </div>
        </div>
    </div>

    <div class="score-board high-score-container">
        <div style="font-weight:bold; margin-bottom:10px; font-size:20px;">ğŸ† ìµœê³  ì ìˆ˜ TOP 5 ğŸ†</div>
        <ol id="highScoreList"></ol>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 30;
        
        const TETROMINOS = {
            I: { shape: [[1, 1, 1, 1]], color: '#00f0f0' },
            O: { shape: [[1, 1], [1, 1]], color: '#f0f000' },
            T: { shape: [[0, 1, 0], [1, 1, 1]], color: '#a000f0' },
            S: { shape: [[0, 1, 1], [1, 1, 0]], color: '#00f000' },
            Z: { shape: [[1, 1, 0], [0, 1, 1]], color: '#f00000' },
            J: { shape: [[1, 0, 0], [1, 1, 1]], color: '#0000f0' },
            L: { shape: [[0, 0, 1], [1, 1, 1]], color: '#f0a000' }
        };
        
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let gameRunning = false;
        let score = 0;
        let level = 1;
        let lines = 0;
        let dropTime = 0;
        let dropInterval = 1000;
        let paused = false;
        let animationFrameId;

        // --- âš™ï¸ jsonbin.io ì„¤ì • (ë§¤ìš° ì¤‘ìš”) ---
        // 2ë‹¨ê³„ì—ì„œ ë³µì‚¬í•œ ë³¸ì¸ì˜ BIN_IDì™€ API_KEYë¡œ êµì²´í•´ì£¼ì„¸ìš”.
        const BIN_ID = 'YOUR_BIN_ID'; // ğŸ‘ˆ ë³¸ì¸ì˜ BIN IDë¡œ êµì²´
        const API_KEY = 'YOUR_API_KEY'; // ğŸ‘ˆ ë³¸ì¸ì˜ Master Keyë¡œ êµì²´
        const HIGH_SCORE_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
        const MAX_HIGH_SCORES = 5;
        
        function initBoard() {
            board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
        }
        
        function createPiece() {
            const pieces = Object.keys(TETROMINOS);
            const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
            const tetromino = TETROMINOS[randomPiece];
            return {
                shape: tetromino.shape,
                color: tetromino.color,
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(tetromino.shape[0].length / 2),
                y: 0
            };
        }
        
        function drawBlock(ctx, x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#333';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
        
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            board.forEach((row, y) => {
                row.forEach((color, x) => {
                    if (color) drawBlock(ctx, x, y, color);
                });
            });
            if (currentPiece) drawPiece(ctx, currentPiece);
        }
        
        function drawPiece(ctx, piece) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) drawBlock(ctx, piece.x + x, piece.y + y, piece.color);
                });
            });
        }
        
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                const pieceSize = 20;
                const offsetX = (nextCanvas.width - nextPiece.shape[0].length * pieceSize) / 2;
                const offsetY = (nextCanvas.height - nextPiece.shape.length * pieceSize) / 2;
                
                nextPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            nextCtx.fillStyle = nextPiece.color;
                            nextCtx.fillRect(offsetX + x * pieceSize, offsetY + y * pieceSize, pieceSize, pieceSize);
                            nextCtx.strokeStyle = '#333';
                            nextCtx.strokeRect(offsetX + x * pieceSize, offsetY + y * pieceSize, pieceSize, pieceSize);
                        }
                    });
                });
            }
        }
        
        function isValidMove(piece, dx, dy, rotation = null) {
            const shape = rotation || piece.shape;
            const newX = piece.x + dx;
            const newY = piece.y + dy;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const newPosX = newX + x;
                        const newPosY = newY + y;
                        if (newPosX < 0 || newPosX >= BOARD_WIDTH || newPosY >= BOARD_HEIGHT || (newPosY >= 0 && board[newPosY][newPosX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        function rotatePiece(piece) {
            const shape = piece.shape;
            return shape[0].map((_, colIndex) => shape.map(row => row[colIndex]).reverse());
        }
        
        function placePiece() {
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
                });
            });
            clearLines();
            currentPiece = nextPiece;
            nextPiece = createPiece();
            
            if (!isValidMove(currentPiece, 0, 0)) gameOver();
        }
        
        function clearLines() {
            let linesCleared = 0;
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    board.splice(y, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(0));
                    linesCleared++;
                    y++; 
                }
            }
            if (linesCleared > 0) {
                lines += linesCleared;
                const scoreMultipliers = [0, 100, 300, 500, 800];
                score += (scoreMultipliers[linesCleared] || scoreMultipliers[4]) * level;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level - 1) * 75);
                updateScore();
            }
        }
        
        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;
        }
        
        async function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';

            const scores = await fetchHighScores();
            const isHighScore = score > 0 && (scores.length < MAX_HIGH_SCORES || score > scores[scores.length-1].score);
            
            const nameBox = document.getElementById('nameInputBox');
            if (isHighScore) {
                nameBox.style.display = 'block';
                document.getElementById('playerName').value = '';
                setTimeout(() => document.getElementById('playerName').focus(), 100);
            } else {
                nameBox.style.display = 'none';
            }
        }
        
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            score = 0;
            level = 1;
            lines = 0;
            dropInterval = 1000;
            updateScore();
            startGame();
        }
        
        function startGame() {
            initBoard();
            currentPiece = createPiece();
            nextPiece = createPiece();
            gameRunning = true;
            paused = false;
            dropTime = Date.now();
            updateHighScoreList();
            gameLoop();
        }
        
        function gameLoop() {
            if (!gameRunning) return;
            if (!paused) {
                update();
                draw();
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function update() {
            const now = Date.now();
            if (now - dropTime > dropInterval) {
                if (isValidMove(currentPiece, 0, 1)) {
                    currentPiece.y++;
                } else {
                    placePiece();
                }
                dropTime = now;
            }
        }
        
        function draw() {
            drawBoard();
            drawNextPiece();
        }

        function togglePause() {
             if (!gameRunning) return;
             paused = !paused;
             if (!paused) {
                 dropTime = Date.now();
             } else {
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                 ctx.fillStyle = 'white';
                 ctx.font = '30px Arial';
                 ctx.textAlign = 'center';
                 ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
             }
        }
        
        document.addEventListener('keydown', (e) => {
            if (paused) {
                 if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') togglePause();
                 return;
            }
            if (!gameRunning) return;
            
            switch (e.key) {
                case 'ArrowLeft': if (isValidMove(currentPiece, -1, 0)) currentPiece.x--; break;
                case 'ArrowRight': if (isValidMove(currentPiece, 1, 0)) currentPiece.x++; break;
                case 'ArrowDown':
                    if (isValidMove(currentPiece, 0, 1)) {
                        currentPiece.y++;
                        score += 1;
                        updateScore();
                    }
                    break;
                case 'ArrowUp':
                    const rotated = rotatePiece(currentPiece);
                    if (isValidMove(currentPiece, 0, 0, rotated)) currentPiece.shape = rotated;
                    break;
                case ' ':
                    e.preventDefault();
                    while (isValidMove(currentPiece, 0, 1)) {
                        currentPiece.y++;
                        score += 2;
                    }
                    updateScore();
                    placePiece();
                    break;
                case 'p': case 'P': case 'Escape': togglePause(); break;
                case 'r': case 'R': restartGame(); break;
            }
        });
        
        // --- ìµœê³  ì ìˆ˜ ê´€ë ¨ í•¨ìˆ˜ (jsonbin.io ì„œë²„ ì—°ë™) ---

        async function fetchHighScores() {
            if (!API_KEY || !BIN_ID || API_KEY === 'YOUR_API_KEY' || BIN_ID === 'YOUR_BIN_ID') {
                 console.warn("jsonbin.io API Key ë˜ëŠ” BIN IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
                 return [];
            }
            try {
                const res = await fetch(`${HIGH_SCORE_URL}/latest`, {
                    headers: { 'X-Master-Key': API_KEY }
                });
                if (!res.ok) return []; // ì˜¤ë¥˜ê°€ ìˆì–´ë„ ë¹ˆ ë°°ì—´ ë°˜í™˜
                const data = await res.json();
                return Array.isArray(data.record) ? data.record : [];
            } catch (e) {
                console.error("ìµœê³  ì ìˆ˜ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:", e);
                return [];
            }
        }

        async function saveHighScoresToServer(scores) {
             if (!API_KEY || !BIN_ID || API_KEY === 'YOUR_API_KEY' || BIN_ID === 'YOUR_BIN_ID') return;
            try {
                await fetch(HIGH_SCORE_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': API_KEY
                    },
                    body: JSON.stringify(scores)
                });
            } catch (e) {
                console.error("ìµœê³  ì ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:", e);
            }
        }

        async function updateHighScoreList() {
            const list = document.getElementById('highScoreList');
            if (!list) return;
            list.innerHTML = '<li>ì ìˆ˜íŒì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</li>';
            
            const scores = await fetchHighScores();
            scores.sort((a, b) => b.score - a.score);

            list.innerHTML = '';
            if (scores.length === 0) {
                 list.innerHTML = '<li>ì•„ì§ ë“±ë¡ëœ ì ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.</li>';
                 return;
            }

            scores.slice(0, MAX_HIGH_SCORES).forEach((entry) => {
                const li = document.createElement('li');
                li.textContent = `${entry.name} - ${entry.score.toLocaleString()}`;
                list.appendChild(li);
            });
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const saveBtn = document.getElementById('saveScoreBtn');
            if (saveBtn) {
                saveBtn.onclick = async function() {
                    this.disabled = true; // ì¤‘ë³µ ì €ì¥ ë°©ì§€
                    const name = document.getElementById('playerName').value.trim() || 'ìµëª…';
                    
                    let scores = await fetchHighScores();
                    scores.push({ name, score });
                    scores.sort((a, b) => b.score - a.score);
                    scores = scores.slice(0, MAX_HIGH_SCORES);
                    
                    await saveHighScoresToServer(scores);
                    await updateHighScoreList();
                    
                    document.getElementById('nameInputBox').style.display = 'none';
                    this.disabled = false;
                };
            }
            startGame();
        });
    </script>
</body>
</html>
```